<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Swipe Dodger (Harder)</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { height: 100%; margin: 0; }
    body {
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display: grid;
      place-items: center;
      background: #0b0f17;
      color: #e9eef7;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
    }
    .wrap { width: min(92vw, 520px); display: grid; gap: 12px; }
    .topbar {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      font-size: 14px;
      opacity: 0.95;
      flex-wrap: wrap;
    }
    .pill {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 6px 10px;
      border-radius: 999px;
    }
    canvas {
      width: 100%;
      aspect-ratio: 3 / 4;
      background: radial-gradient(1200px 800px at 50% 15%, rgba(120,160,255,0.20), transparent 55%),
                  linear-gradient(180deg, #0b0f17, #070a10);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      display: block;
    }
    .controls { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: inherit;
      border-radius: 14px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 600;
    }
    button:active { transform: translateY(1px); }
    .hint {
      font-size: 13px;
      opacity: 0.8;
      line-height: 1.35;
      padding: 0 2px;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill">Level: <span id="level">1</span></div>
      <div class="pill">Edge: <span id="edge">OK</span></div>
    </div>

    <canvas id="c" width="600" height="800" aria-label="Game canvas"></canvas>

    <div class="controls">
      <button id="startBtn">Start / Restart</button>
      <button id="pauseBtn">Pause</button>
    </div>

    <div class="hint">
      Dodge the falling blocks.<br/>
      iPad: <span class="kbd">Swipe</span>/<span class="kbd">drag</span>. Keyboard: <span class="kbd">←</span>/<span class="kbd">→</span> or <span class="kbd">A</span>/<span class="kbd">D</span>.<br/>
      New: camping the walls too long will end you.
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const levelEl = document.getElementById('level');
  const edgeEl  = document.getElementById('edge');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const rand  = (a, b) => a + Math.random() * (b - a);

  const BEST_KEY = 'swipeDodgerBest_v2_harder';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = String(best);

  const W = canvas.width, H = canvas.height;

  const ship = {
    w: 64, h: 36,
    x: W/2, y: H - 90,
    vx: 0,
    speed: 760,
  };

  let obstacles = [];
  let particles = [];

  let running = false;
  let paused = false;
  let gameOver = false;

  let score = 0;
  let level = 1;

  let spawnTimer = 0;
  let spawnEvery = 0.82;
  let obstacleSpeed = 270;

  // NEW: edge camping penalty
  const EDGE_MARGIN = 85;       // how close counts as "edge"
  const EDGE_LIMIT  = 1.9;      // seconds allowed at edge before death
  let edgeTime = 0;             // accumulates while at edge

  // input
  let leftHeld = false, rightHeld = false;
  let pointerDown = false;
  let pointerStartX = 0;
  let shipStartX = 0;

  function roundedRect(x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawShip() {
    const x = ship.x - ship.w/2;
    const y = ship.y - ship.h/2;

    ctx.save();
    ctx.shadowColor = 'rgba(120,160,255,0.6)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'rgba(120,160,255,0.14)';
    roundedRect(x-6, y-6, ship.w+12, ship.h+12, 18);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#7aa2ff';
    roundedRect(x, y, ship.w, ship.h, 16);
    ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    roundedRect(x + ship.w*0.58, y + ship.h*0.22, ship.w*0.30, ship.h*0.56, 12);
    ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    roundedRect(x + 8, y + ship.h*0.30, ship.w*0.16, ship.h*0.40, 10);
    ctx.fill();
  }

  function drawObstacle(o) {
    ctx.save();
    ctx.shadowColor = o.seeker ? 'rgba(255,180,80,0.55)' : 'rgba(255,80,100,0.45)';
    ctx.shadowBlur = 14;
    ctx.fillStyle = o.seeker ? '#ffb24f' : '#ff4f64';
    roundedRect(o.x - o.w/2, o.y - o.h/2, o.w, o.h, 14);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    roundedRect(o.x - o.w/2 + 8, o.y - o.h/2 + 10, o.w - 16, 10, 10);
    ctx.fill();
  }

  function drawParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= dt;
      if (p.life <= 0) { particles.splice(i, 1); continue; }
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 600 * dt;
      const a = clamp(p.life / p.maxLife, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function spawnExplosion(x, y) {
    const n = 28;
    for (let i = 0; i < n; i++) {
      const ang = rand(0, Math.PI * 2);
      const sp = rand(170, 560);
      particles.push({
        x, y,
        vx: Math.cos(ang) * sp,
        vy: Math.sin(ang) * sp - rand(0, 230),
        r: rand(2.5, 6),
        life: rand(0.35, 0.80),
        maxLife: 0.80,
        color: Math.random() < 0.65 ? 'rgba(255,80,100,0.95)' : 'rgba(255,255,255,0.85)',
      });
    }
  }

  function reset() {
    obstacles = [];
    particles = [];
    score = 0;
    level = 1;
    spawnTimer = 0;
    spawnEvery = 0.82;
    obstacleSpeed = 270;

    ship.x = W/2;
    ship.vx = 0;

    edgeTime = 0;
    edgeEl.textContent = 'OK';

    running = true;
    paused = false;
    gameOver = false;

    scoreEl.textContent = '0';
    levelEl.textContent = '1';
    pauseBtn.textContent = 'Pause';
  }

  function spawnObstacle() {
    const w = rand(54, 92);
    const h = rand(48, 86);

    // Slight bias away from dead-center to reduce "one perfect lane"
    const bias = (Math.random() < 0.5) ? -1 : 1;
    const base = W/2 + bias * rand(40, 160);
    const x = clamp(base + rand(-80, 80), w/2 + 16, W - w/2 - 16);
    const y = -h;

    let speed = obstacleSpeed * rand(0.95, 1.30);
    let ww = w, hh = h;

    // NEW: seeker chance increases with level (capped)
    const seekerChance = clamp(0.10 + (level - 1) * 0.02, 0.10, 0.28);
    const seeker = Math.random() < seekerChance;

    // Variety
    const kind = Math.random();
    if (kind < 0.14) { ww = rand(44, 60); hh = rand(70, 120); speed *= 1.18; }
    else if (kind > 0.86) { ww = rand(86, 120); hh = rand(44, 64); speed *= 0.98; }

    // Seeker lateral drift strength
    const steer = seeker ? (170 + (level - 1) * 10) : 0;

    obstacles.push({ x, y, w: ww, h: hh, vy: speed, seeker, steer });
  }

  function updateDifficulty() {
    const newLevel = 1 + Math.floor(score / 10);
    if (newLevel !== level) {
      level = newLevel;
      levelEl.textContent = String(level);

      spawnEvery = clamp(0.82 - (level - 1) * 0.06, 0.34, 0.82);
      obstacleSpeed = 270 + (level - 1) * 26;
    }
  }

  function collide(a, b) {
    const ax1 = a.x - a.w/2, ax2 = a.x + a.w/2;
    const ay1 = a.y - a.h/2, ay2 = a.y + a.h/2;
    const bx1 = b.x - b.w/2, bx2 = b.x + b.w/2;
    const by1 = b.y - b.h/2, by2 = b.y + b.h/2;
    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
  }

  function setGameOver(reasonText) {
    gameOver = true;
    running = false;
    spawnExplosion(ship.x, ship.y);

    if (score > best) {
      best = score;
      localStorage.setItem(BEST_KEY, String(best));
      bestEl.textContent = String(best);
    }

    if (reasonText) edgeEl.textContent = reasonText;
  }

  function drawBackground() {
    // edge danger zones (subtle red glow)
    const warn = clamp(edgeTime / EDGE_LIMIT, 0, 1);

    if (warn > 0) {
      ctx.save();
      ctx.globalAlpha = 0.25 * warn;
      ctx.fillStyle = '#ff4f64';
      ctx.fillRect(0, 0, EDGE_MARGIN, H);
      ctx.fillRect(W - EDGE_MARGIN, 0, EDGE_MARGIN, H);
      ctx.restore();
    }

    ctx.save();
    ctx.globalAlpha = 0.35;
    for (let i = 0; i < 42; i++) {
      const x = (i * 97) % W;
      const y = ((i * 211) % H);
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(22, ship.y - 10);
    ctx.lineTo(W - 22, ship.y - 10);
    ctx.stroke();
    ctx.restore();
  }

  function drawOverlay(text1, text2) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    roundedRect(30, 250, W - 60, 300, 22);
    ctx.fill();

    ctx.fillStyle = '#e9eef7';
    ctx.textAlign = 'center';
    ctx.font = '700 44px -apple-system, system-ui, sans-serif';
    ctx.fillText(text1, W/2, 350);

    ctx.globalAlpha = 0.92;
    ctx.font = '500 18px -apple-system, system-ui, sans-serif';
    ctx.fillText(text2, W/2, 402);

    ctx.globalAlpha = 0.85;
    ctx.font = '500 16px -apple-system, system-ui, sans-serif';
    ctx.fillText('Tap Start / Restart', W/2, 455);
    ctx.restore();
  }

  let last = performance.now();
  function frame(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    ctx.clearRect(0, 0, W, H);
    drawBackground();

    if (running && !paused) {
      const target = (rightHeld ? 1 : 0) - (leftHeld ? 1 : 0);
      ship.vx = target * ship.speed;

      ship.x += ship.vx * dt;
      ship.x = clamp(ship.x, ship.w/2 + 14, W - ship.w/2 - 14);

      // NEW: edge timer
      const atEdge = (ship.x < EDGE_MARGIN) || (ship.x > W - EDGE_MARGIN);
      if (atEdge) edgeTime += dt;
      else edgeTime = Math.max(0, edgeTime - dt * 1.4); // recover faster than you build up

      const remaining = EDGE_LIMIT - edgeTime;
      if (edgeTime <= 0.05) edgeEl.textContent = 'OK';
      else edgeEl.textContent = remaining <= 0 ? 'DEAD' : remaining.toFixed(1) + 's';

      if (edgeTime >= EDGE_LIMIT) {
        setGameOver('Edge camping');
      }

      // spawn
      spawnTimer += dt;
      while (spawnTimer >= spawnEvery) {
        spawnTimer -= spawnEvery;
        spawnObstacle();
      }

      // obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];

        // NEW: seekers drift toward ship
        if (o.seeker) {
          const dir = Math.sign(ship.x - o.x);
          o.x += dir * o.steer * dt;
          o.x = clamp(o.x, o.w/2 + 16, W - o.w/2 - 16);
        }

        o.y += o.vy * dt;

        if (o.y - o.h/2 > H + 20) {
          obstacles.splice(i, 1);
          score += 1;
          scoreEl.textContent = String(score);
          updateDifficulty();
          continue;
        }

        if (!gameOver && collide(ship, o)) {
          setGameOver('Hit');
          break;
        }
      }
    }

    for (const o of obstacles) drawObstacle(o);
    drawShip();
    drawParticles(dt);

    if (!running && !gameOver && !paused) {
      drawOverlay('Swipe Dodger', 'Now with seekers + edge penalty.');
    } else if (paused) {
      drawOverlay('Paused', 'Resume when ready.');
    } else if (gameOver) {
      drawOverlay('Game Over', `Final score: ${score}`);
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  startBtn.addEventListener('click', () => reset());

  pauseBtn.addEventListener('click', () => {
    if (!running && !gameOver) return;
    if (gameOver) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  });

  function pointerPosX(e) {
    const rect = canvas.getBoundingClientRect();
    return (e.clientX - rect.left) / rect.width * W;
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointerDown = true;
    pointerStartX = pointerPosX(e);
    shipStartX = ship.x;

    if (!running && !gameOver && !paused) reset();
    if (gameOver) reset();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointerDown) return;
    const x = pointerPosX(e);
    const dx = x - pointerStartX;
    ship.x = clamp(shipStartX + dx, ship.w/2 + 14, W - ship.w/2 - 14);
  });

  canvas.addEventListener('pointerup', () => { pointerDown = false; });
  canvas.addEventListener('pointercancel', () => { pointerDown = false; });

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'arrowleft' || k === 'a') leftHeld = true;
    if (k === 'arrowright' || k === 'd') rightHeld = true;

    if (k === ' ' || k === 'enter') {
      if (!running || gameOver) reset();
      else {
        paused = !paused;
        pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      }
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'arrowleft' || k === 'a') leftHeld = false;
    if (k === 'arrowright' || k === 'd') rightHeld = false;
  });

  running = false;
  paused = false;
  gameOver = false;
})();
</script>
</body>
</html>
