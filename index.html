<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Spellpaint Arena (Single File)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; }
    body{
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:#060810;
      color:#e9eef7;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action:none;
    }
    .wrap{ width:min(94vw, 760px); display:grid; gap:10px; }
    .top{
      display:flex; flex-wrap:wrap; gap:8px; justify-content:space-between; align-items:center;
      font-size:14px;
    }
    .pill{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 6px 10px;
      border-radius: 999px;
      display:inline-flex; gap:8px; align-items:baseline;
      white-space:nowrap;
    }
    .pill strong{ font-weight:800; }
    canvas{
      width:100%;
      aspect-ratio: 16 / 10;
      background:
        radial-gradient(1200px 900px at 50% 10%, rgba(120,160,255,0.18), transparent 60%),
        radial-gradient(1000px 800px at 20% 80%, rgba(255,120,210,0.08), transparent 60%),
        linear-gradient(180deg, #060810, #04050a);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      display:block;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: inherit;
      border-radius: 14px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 800;
    }
    button:active{ transform: translateY(1px); }
    .hint{
      font-size:13px; opacity:0.82; line-height:1.35; padding: 0 2px;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      white-space:nowrap;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="pill">Score <strong id="score">0</strong> · Best <strong id="best">0</strong></div>
    <div class="pill">HP <strong id="hp">10</strong>/<span id="hpmax">10</span> · Wave <strong id="wave">1</strong></div>
    <div class="pill">Status <span id="status">Drag to cast.</span></div>
  </div>

  <canvas id="c" width="1280" height="800" aria-label="Spellpaint Arena"></canvas>

  <div class="controls">
    <button id="startBtn">Start / Restart</button>
    <button id="pauseBtn">Pause</button>
    <button id="modeBtn">Spell: Vortex</button>
  </div>

  <div class="hint">
    iPad: <span class="kbd">drag</span> to cast. Desktop: hold mouse and move. Enemies chase you. Paint them.
    <br/>Tip: stay moving — if they touch you, you take damage.
  </div>
</div>

<script>
(() => {
  // ===== DOM =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const hpEl    = document.getElementById('hp');
  const hpMaxEl = document.getElementById('hpmax');
  const waveEl  = document.getElementById('wave');
  const statusEl= document.getElementById('status');
  const startBtn= document.getElementById('startBtn');
  const pauseBtn= document.getElementById('pauseBtn');
  const modeBtn = document.getElementById('modeBtn');

  // ===== Helpers =====
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const rand = (a,b) => a + Math.random()*(b-a);
  const hypot = Math.hypot;

  // ===== Storage =====
  const BEST_KEY = 'spellpaint_arena_best_v1';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = String(best);

  // ===== World =====
  const W = canvas.width, H = canvas.height;

  let running = false;
  let paused = false;
  let gameOver = false;

  let score = 0;
  let wave = 1;

  const player = {
    x: W*0.5, y: H*0.58,
    r: 16,
    hp: 10, hpMax: 10,
    speed: 520, // px/sec
    vx: 0, vy: 0,
    invuln: 0
  };

  // input
  let pointerDown = false;
  let pointerId = null;
  let pointerX = player.x, pointerY = player.y;
  let lastPointerX = player.x, lastPointerY = player.y;

  // spell brush (particle-fluid-ish)
  let spells = [];     // particles that deal damage
  let sparks = [];     // visuals
  let enemies = [];    // {x,y,r,hp,speed,touchCd}
  let blobs = [];      // background drifting glow blobs

  let spawnTimer = 0;
  let spawnEvery = 0.85;
  let enemyBaseHP = 5;
  let enemyBaseSpeed = 95;

  // spell modes
  const SpellMode = {
    VORTEX: 0,
    RAY: 1,
    NOVA: 2
  };
  let spellMode = SpellMode.VORTEX;

  function setStatus(s){ statusEl.textContent = s; }

  function syncUI(){
    scoreEl.textContent = String(score);
    hpEl.textContent = String(Math.max(0, Math.ceil(player.hp)));
    hpMaxEl.textContent = String(player.hpMax);
    waveEl.textContent = String(wave);
    bestEl.textContent = String(best);
  }

  function reset() {
    running = true;
    paused = false;
    gameOver = false;

    score = 0;
    wave = 1;

    player.x = W*0.5; player.y = H*0.58;
    player.vx = 0; player.vy = 0;
    player.hpMax = 10; player.hp = 10;
    player.invuln = 0;

    spells = [];
    sparks = [];
    enemies = [];
    blobs = makeBlobs(10);

    spawnTimer = 0;
    spawnEvery = 0.85;
    enemyBaseHP = 5;
    enemyBaseSpeed = 95;

    pauseBtn.textContent = 'Pause';
    setStatus('Drag to cast.');
    syncUI();
  }

  function gameOverNow() {
    gameOver = true;
    running = false;
    paused = false;

    if (score > best) {
      best = score;
      localStorage.setItem(BEST_KEY, String(best));
    }
    setStatus('Game over. Restart?');
    syncUI();

    // burst
    for (let i=0;i<90;i++) {
      sparks.push(makeSpark(player.x, player.y, 1.0, true));
    }
  }

  // ===== Background blobs =====
  function makeBlobs(n){
    const arr = [];
    for (let i=0;i<n;i++){
      arr.push({
        x: rand(0,W), y: rand(0,H),
        r: rand(60, 190),
        vx: rand(-22, 22),
        vy: rand(-18, 18),
        a: rand(0.06, 0.16),
        hue: rand(190, 310)
      });
    }
    return arr;
  }

  // ===== Coordinate mapping =====
  function toWorld(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width * W;
    const y = (e.clientY - rect.top) / rect.height * H;
    return {x,y};
  }

  // ===== Enemy spawning =====
  function spawnEnemy() {
    const edge = Math.floor(rand(0,4));
    let x,y;
    if (edge===0) { x = rand(0,W); y = -30; }
    else if (edge===1) { x = W+30; y = rand(0,H); }
    else if (edge===2) { x = rand(0,W); y = H+30; }
    else { x = -30; y = rand(0,H); }

    const r = rand(14, 26);
    const hp = enemyBaseHP + rand(-1, 2) + Math.floor(wave*0.6);
    const speed = enemyBaseSpeed + rand(-10, 25) + wave*6;

    enemies.push({ x,y,r,hp, speed, touchCd: 0 });
  }

  function advanceDifficulty() {
    const newWave = 1 + Math.floor(score / 35);
    if (newWave !== wave) {
      wave = newWave;
      // faster spawns + tougher enemies
      spawnEvery = clamp(0.85 - (wave-1)*0.07, 0.34, 0.85);
      enemyBaseHP = 5 + (wave-1)*2;
      enemyBaseSpeed = 95 + (wave-1)*10;
      player.hpMax = 10 + Math.floor((wave-1)*1.5);
      player.hp = clamp(player.hp + 2, 0, player.hpMax);
      setStatus(`Wave ${wave}.`);
      syncUI();
    }
  }

  // ===== Particles =====
  function makeSpellParticle(x,y,vx,vy,life,rad,power,hue){
    return { x,y,vx,vy, life, maxLife: life, r: rad, power, hue };
  }
  function makeSpark(x,y,strength,white=false){
    const a = rand(0, Math.PI*2);
    const sp = rand(180, 780) * strength;
    return {
      x,y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - rand(0, 240),
      r: rand(1.5, 4.5) * (white ? 1.2 : 1),
      life: rand(0.25, 0.85),
      maxLife: 0.85,
      hue: white ? 0 : rand(190, 320),
      white
    };
  }

  // ===== Spell casting =====
  function cast(dt){
    // player movement: gently follow pointer while casting (so it feels "arena")
    // player tries to stay somewhat under your finger
    const dx = pointerX - player.x;
    const dy = pointerY - player.y;
    const dist = Math.hypot(dx,dy);
    const pull = pointerDown ? 1 : 0.75;
    const maxStep = player.speed * dt * pull;

    if (dist > 1) {
      player.x += clamp(dx, -maxStep, maxStep);
      player.y += clamp(dy, -maxStep, maxStep);
    }

    player.x = clamp(player.x, 20, W-20);
    player.y = clamp(player.y, 20, H-20);

    // emit based on spell mode
    const vx = (pointerX - lastPointerX) / Math.max(0.001, dt);
    const vy = (pointerY - lastPointerY) / Math.max(0.001, dt);
    const speed = Math.hypot(vx,vy);

    // emission rate depends on motion
    const emit = pointerDown ? clamp(Math.floor(6 + speed/220), 6, 20) : 0;

    if (emit <= 0) return;

    if (spellMode === SpellMode.VORTEX) {
      // swirl around pointer: looks fluid-ish
      for (let i=0;i<emit;i++){
        const ang = rand(0, Math.PI*2);
        const rr = rand(4, 26);
        const px = pointerX + Math.cos(ang)*rr;
        const py = pointerY + Math.sin(ang)*rr;

        const swirl = 1;
        const tvx = -Math.sin(ang) * rand(140, 420) * swirl + rand(-40,40);
        const tvy =  Math.cos(ang) * rand(140, 420) * swirl + rand(-40,40);

        const life = rand(0.35, 0.85);
        const rad  = rand(6, 16);
        const power= rand(0.7, 1.15);
        const hue  = rand(190, 310);
        spells.push(makeSpellParticle(px,py,tvx,tvy,life,rad,power,hue));
      }
    } else if (spellMode === SpellMode.RAY) {
      // beam-ish: particles stream forward from player toward pointer
      const ax = pointerX - player.x, ay = pointerY - player.y;
      const d = Math.hypot(ax,ay) || 1;
      const nx = ax/d, ny = ay/d;
      for (let i=0;i<emit;i++){
        const spread = rand(-0.25,0.25);
        const sx = nx*Math.cos(spread) - ny*Math.sin(spread);
        const sy = nx*Math.sin(spread) + ny*Math.cos(spread);
        const px = player.x + sx*26 + rand(-6,6);
        const py = player.y + sy*26 + rand(-6,6);
        const sp = rand(520, 980);
        const tvx = sx*sp + rand(-50,50);
        const tvy = sy*sp + rand(-50,50);
        spells.push(makeSpellParticle(px,py,tvx,tvy,rand(0.22,0.50),rand(4,10),rand(0.9,1.3),rand(200,290)));
      }
    } else {
      // NOVA: ring bursts around pointer while dragging
      for (let i=0;i<emit;i++){
        const ang = rand(0, Math.PI*2);
        const px = pointerX + Math.cos(ang)*rand(0,12);
        const py = pointerY + Math.sin(ang)*rand(0,12);
        const sp = rand(360, 760);
        spells.push(makeSpellParticle(px,py,Math.cos(ang)*sp,Math.sin(ang)*sp,rand(0.30,0.65),rand(6,14),rand(0.85,1.25),rand(260,330)));
      }
    }

    // sparks (just visuals) — cheaper than spells
    const nS = Math.floor(emit/2);
    for (let i=0;i<nS;i++){
      sparks.push(makeSpark(pointerX, pointerY, 0.45, false));
    }
  }

  // ===== Physics / Damage =====
  function updateSpells(dt){
    for (let i=spells.length-1;i>=0;i--){
      const p = spells[i];
      p.life -= dt;
      if (p.life <= 0) { spells.splice(i,1); continue; }

      // drag + mild curl to feel "fluid"
      p.vx *= (1 - dt*1.6);
      p.vy *= (1 - dt*1.6);

      // tiny curl around pointer when casting
      const dx = p.x - pointerX, dy = p.y - pointerY;
      const d = Math.hypot(dx,dy) || 1;
      const curl = pointerDown ? 140 : 40;
      p.vx += (-dy/d) * curl * dt * 0.25;
      p.vy += ( dx/d) * curl * dt * 0.25;

      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // keep in bounds a bit
      if (p.x < -60 || p.y < -60 || p.x > W+60 || p.y > H+60) {
        spells.splice(i,1);
      }
    }
  }

  function updateSparks(dt){
    for (let i=sparks.length-1;i>=0;i--){
      const s = sparks[i];
      s.life -= dt;
      if (s.life <= 0) { sparks.splice(i,1); continue; }
      s.x += s.vx*dt;
      s.y += s.vy*dt;
      s.vy += 520*dt;
      s.vx *= (1 - dt*0.8);
      s.vy *= (1 - dt*0.2);
    }
  }

  function updateEnemies(dt){
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      e.touchCd = Math.max(0, e.touchCd - dt);

      // chase player
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const d = Math.hypot(dx,dy) || 1;
      const nx = dx/d, ny = dy/d;

      // mild "avoid clumping"
      let ax = 0, ay = 0;
      for (let j=0;j<enemies.length;j++){
        if (j===i) continue;
        const o = enemies[j];
        const ddx = e.x - o.x;
        const ddy = e.y - o.y;
        const dist = Math.hypot(ddx,ddy);
        if (dist > 0 && dist < 44) {
          ax += (ddx/dist) * (44 - dist) * 0.9;
          ay += (ddy/dist) * (44 - dist) * 0.9;
        }
      }

      const vx = nx*e.speed + ax;
      const vy = ny*e.speed + ay;
      e.x += vx*dt;
      e.y += vy*dt;

      // contact damage
      const pd = Math.hypot(e.x - player.x, e.y - player.y);
      if (pd < e.r + player.r + 2) {
        if (player.invuln <= 0 && e.touchCd <= 0) {
          player.hp -= 1.2;
          player.invuln = 0.25;
          e.touchCd = 0.35;
          setStatus('Ouch.');
          if (player.hp <= 0) { gameOverNow(); return; }
        }
      }

      // spell damage: check against nearby spell particles
      // (simple: sample a few spells each enemy per frame)
      if (spells.length) {
        const checks = Math.min(18, spells.length);
        for (let k=0;k<checks;k++){
          const idx = (Math.random() * spells.length) | 0;
          const p = spells[idx];
          const dd = Math.hypot(e.x - p.x, e.y - p.y);
          if (dd < e.r + p.r) {
            e.hp -= p.power * 0.55;
            // impact spark
            if (Math.random() < 0.25) sparks.push(makeSpark(e.x, e.y, 0.5, false));
            // "consume" some energy
            p.life -= 0.06;
          }
        }
      }

      if (e.hp <= 0) {
        enemies.splice(i,1);
        score += 3;
        // death burst
        for (let b=0;b<18;b++) sparks.push(makeSpark(e.x, e.y, 0.7, Math.random()<0.25));
        if (Math.random() < 0.12) {
          // small heal pickup effect: just heal directly (no item to chase)
          player.hp = clamp(player.hp + 0.8, 0, player.hpMax);
        }
        advanceDifficulty();
        syncUI();
      }
    }
  }

  function updateBlobs(dt){
    for (const b of blobs){
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      if (b.x < -200) b.x = W+200;
      if (b.x > W+200) b.x = -200;
      if (b.y < -200) b.y = H+200;
      if (b.y > H+200) b.y = -200;
    }
  }

  // ===== Rendering =====
  function drawBackground(){
    // drifting glow blobs
    for (const b of blobs){
      ctx.save();
      ctx.globalAlpha = b.a;
      const grad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
      grad.addColorStop(0, `hsla(${b.hue}, 90%, 60%, 1)`);
      grad.addColorStop(1, `hsla(${b.hue}, 90%, 60%, 0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // subtle floor noise dots
    ctx.save();
    ctx.globalAlpha = 0.20;
    for (let i=0;i<70;i++){
      const x = (i*97)%W;
      const y = (i*211)%H;
      ctx.fillStyle = 'rgba(255,255,255,0.10)';
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();
  }

  function drawPlayer(){
    ctx.save();
    const a = player.invuln > 0 ? 0.55 : 1;
    ctx.globalAlpha = a;

    ctx.shadowColor = 'rgba(120,160,255,0.65)';
    ctx.shadowBlur = 22;
    ctx.fillStyle = 'rgba(120,160,255,0.92)';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();

    // aim ring
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r+10, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function drawEnemies(){
    for (const e of enemies){
      ctx.save();
      ctx.shadowColor = 'rgba(255,90,120,0.55)';
      ctx.shadowBlur = 18;
      ctx.fillStyle = 'rgba(255,90,120,0.92)';
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();

      // hp arc
      const pct = clamp(e.hp / (enemyBaseHP + Math.floor(wave*0.6) + 2), 0, 1);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(0,0,0,0.45)';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r+10, 0, Math.PI*2);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r+10, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct);
      ctx.stroke();

      ctx.restore();
    }
  }

  function drawSpells(){
    // additive-ish glow look
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const p of spells){
      const a = clamp(p.life / p.maxLife, 0, 1);
      ctx.globalAlpha = 0.40 * a;

      const r = p.r * (0.9 + (1-a)*0.4);
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r*2.4);
      grad.addColorStop(0, `hsla(${p.hue}, 95%, 65%, 0.95)`);
      grad.addColorStop(0.45, `hsla(${p.hue}, 95%, 60%, 0.35)`);
      grad.addColorStop(1, `hsla(${p.hue}, 95%, 60%, 0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r*2.4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawSparks(){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const s of sparks){
      const a = clamp(s.life / s.maxLife, 0, 1);
      ctx.globalAlpha = a;
      if (s.white) ctx.fillStyle = `rgba(255,255,255,${0.9*a})`;
      else ctx.fillStyle = `hsla(${s.hue}, 95%, 70%, ${0.9*a})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawOverlay(text1, text2){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#e9eef7';
    ctx.textAlign = 'center';
    ctx.font = '900 56px -apple-system, system-ui, sans-serif';
    ctx.fillText(text1, W/2, H/2 - 10);
    ctx.globalAlpha = 0.92;
    ctx.font = '600 18px -apple-system, system-ui, sans-serif';
    ctx.fillText(text2, W/2, H/2 + 32);
    ctx.globalAlpha = 0.85;
    ctx.font = '600 16px -apple-system, system-ui, sans-serif';
    ctx.fillText('Drag to cast. Avoid contact.', W/2, H/2 + 62);
    ctx.restore();
  }

  // ===== Main loop =====
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    ctx.clearRect(0,0,W,H);

    drawBackground();

    if (running && !paused && !gameOver){
      player.invuln = Math.max(0, player.invuln - dt);

      updateBlobs(dt);
      cast(dt);
      updateSpells(dt);
      updateSparks(dt);

      spawnTimer += dt;
      while (spawnTimer >= spawnEvery){
        spawnTimer -= spawnEvery;
        spawnEnemy();
      }

      updateEnemies(dt);
      syncUI();
    } else {
      updateBlobs(dt);
      updateSpells(dt);
      updateSparks(dt);
    }

    drawSpells();
    drawSparks();
    drawEnemies();
    drawPlayer();

    if (!running && !gameOver && !paused){
      drawOverlay('Spellpaint Arena', 'Start, then drag to cast.');
    }
    if (paused){
      drawOverlay('Paused', 'Tap Pause to resume.');
    }
    if (gameOver){
      drawOverlay('Game Over', `Score: ${score}  ·  Best: ${best}`);
    }

    // crosshair / pointer hint
    if (pointerDown && running && !paused && !gameOver){
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(pointerX, pointerY, 18, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ===== Input =====
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointerDown = true;
    pointerId = e.pointerId;
    const p = toWorld(e);
    pointerX = p.x; pointerY = p.y;
    lastPointerX = p.x; lastPointerY = p.y;

    if (!running && !gameOver && !paused) {
      reset();
      setStatus('Go.');
    }
    if (gameOver){
      reset();
      setStatus('Go.');
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointerDown) return;
    const p = toWorld(e);
    lastPointerX = pointerX; lastPointerY = pointerY;
    pointerX = p.x; pointerY = p.y;
  });

  function endPointer(){
    pointerDown = false;
    pointerId = null;
  }
  canvas.addEventListener('pointerup', endPointer);
  canvas.addEventListener('pointercancel', endPointer);

  // Buttons
  startBtn.addEventListener('click', () => { reset(); });
  pauseBtn.addEventListener('click', () => {
    if (!running && !gameOver) return;
    if (gameOver) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  });

  modeBtn.addEventListener('click', () => {
    spellMode = (spellMode + 1) % 3;
    if (spellMode === SpellMode.VORTEX) modeBtn.textContent = 'Spell: Vortex';
    else if (spellMode === SpellMode.RAY) modeBtn.textContent = 'Spell: Ray';
    else modeBtn.textContent = 'Spell: Nova';
  });

  // ===== Start screen state =====
  running = false;
  paused = false;
  gameOver = false;
  blobs = makeBlobs(10);
  setStatus('Drag to cast.');
  syncUI();
})();
</script>
</body>
</html>
