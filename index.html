<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Procedural Dungeon Crawler (Single File)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; }
    body{
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:#070a10;
      color:#e9eef7;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }
    .wrap{ width:min(94vw, 780px); display:grid; gap:10px; }
    .top{
      display:flex; flex-wrap:wrap; gap:8px; justify-content:space-between; align-items:center;
      font-size:14px;
    }
    .pill{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 6px 10px;
      border-radius: 999px;
      display:inline-flex; gap:8px; align-items:baseline;
      white-space:nowrap;
    }
    .pill strong{ font-weight:800; }
    .row{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    canvas{
      width:100%;
      aspect-ratio: 1 / 1;
      background:
        radial-gradient(1000px 800px at 50% 10%, rgba(110,140,255,0.18), transparent 60%),
        linear-gradient(180deg, #070a10, #05070c);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      display:block;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: inherit;
      border-radius: 14px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 700;
    }
    button:active{ transform: translateY(1px); }
    .hint{
      font-size:13px; opacity:0.82; line-height:1.35; padding: 0 2px;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      white-space:nowrap;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="pill">Floor <strong id="floor">1</strong> · Seed <span id="seed">—</span></div>
    <div class="pill">HP <strong id="hp">10</strong>/<span id="hpmax">10</span> · ATK <strong id="atk">2</strong> · Gold <strong id="gold">0</strong></div>
    <div class="pill">Status <span id="status">Explore.</span></div>
  </div>

  <div class="row">
    <canvas id="c" width="900" height="900" aria-label="Dungeon canvas"></canvas>
  </div>

  <div class="controls">
    <button id="newBtn">New Dungeon</button>
    <button id="nextBtn">Next Floor</button>
  </div>

  <div class="hint">
    Move: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> or <span class="kbd">←</span><span class="kbd">↑</span><span class="kbd">→</span><span class="kbd">↓</span>. iPad: swipe on the map.
    <br/>Legend: <span class="kbd">@</span> you, <span class="kbd">E</span> enemy, <span class="kbd">♥</span> heal, <span class="kbd">$</span> gold, <span class="kbd">↧</span> stairs.
  </div>
</div>

<script>
(() => {
  // ========= DOM =========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const floorEl = document.getElementById('floor');
  const seedEl = document.getElementById('seed');
  const hpEl = document.getElementById('hp');
  const hpMaxEl = document.getElementById('hpmax');
  const atkEl = document.getElementById('atk');
  const goldEl = document.getElementById('gold');
  const statusEl = document.getElementById('status');
  const newBtn = document.getElementById('newBtn');
  const nextBtn = document.getElementById('nextBtn');

  // ========= Helpers =========
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const manhattan = (a,b) => Math.abs(a.x-b.x)+Math.abs(a.y-b.y);

  // Seeded RNG (Mulberry32)
  function mulberry32(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }
  function makeSeed() {
    // reasonably "random" without crypto
    const s = (Date.now() ^ (Math.random()*1e9)|0) >>> 0;
    return s || 123456789;
  }

  // ========= Game Config =========
  const W = 35, H = 35;              // grid size
  const ROOM_ATTEMPTS = 70;
  const MIN_ROOM = 4, MAX_ROOM = 9;
  const MAX_ENEMIES_BASE = 7;
  const VIEW_RADIUS = 7;             // fog of war radius

  // Tile types
  const T = {
    WALL: 0,
    FLOOR: 1
  };

  // Items
  const IT = {
    NONE: 0,
    GOLD: 1,
    HEAL: 2,
    STAIRS: 3
  };

  // ========= State =========
  let rng = mulberry32(1);
  let seed = 1;
  let floor = 1;

  let grid = [];        // tiles
  let seen = [];        // fog-of-war memory
  let items = [];       // item type per cell
  let enemies = [];     // list of {x,y,hp,atk}
  let player = { x: 1, y: 1, hp: 10, hpMax: 10, atk: 2, gold: 0 };

  // Swipe controls
  let touchStart = null;

  // ========= Generation =========
  function initArrays() {
    grid = Array.from({length: H}, () => Array(W).fill(T.WALL));
    seen = Array.from({length: H}, () => Array(W).fill(false));
    items = Array.from({length: H}, () => Array(W).fill(IT.NONE));
    enemies = [];
  }

  function randInt(a, b) { // inclusive
    return a + Math.floor(rng() * (b - a + 1));
  }

  function carveRoom(x, y, w, h) {
    for (let yy = y; yy < y + h; yy++) {
      for (let xx = x; xx < x + w; xx++) {
        if (xx<=0 || yy<=0 || xx>=W-1 || yy>=H-1) continue;
        grid[yy][xx] = T.FLOOR;
      }
    }
  }

  function roomIntersects(r, rooms) {
    for (const o of rooms) {
      if (r.x <= o.x + o.w + 1 &&
          r.x + r.w + 1 >= o.x &&
          r.y <= o.y + o.h + 1 &&
          r.y + r.h + 1 >= o.y) return true;
    }
    return false;
  }

  function carveCorridor(a, b) {
    // L-shaped corridor
    let x = a.x, y = a.y;
    const horizFirst = rng() < 0.5;
    function digTo(tx, ty) {
      while (x !== tx) {
        grid[y][x] = T.FLOOR;
        x += Math.sign(tx - x);
      }
      while (y !== ty) {
        grid[y][x] = T.FLOOR;
        y += Math.sign(ty - y);
      }
      grid[y][x] = T.FLOOR;
    }
    if (horizFirst) {
      digTo(b.x, a.y);
      digTo(b.x, b.y);
    } else {
      digTo(a.x, b.y);
      digTo(b.x, b.y);
    }
  }

  function randomFloorCell() {
    for (let tries = 0; tries < 5000; tries++) {
      const x = randInt(1, W-2);
      const y = randInt(1, H-2);
      if (grid[y][x] === T.FLOOR && items[y][x] === IT.NONE && !enemyAt(x,y) && !(player.x===x && player.y===y)) {
        return {x,y};
      }
    }
    // fallback scan
    for (let y=1;y<H-1;y++) for (let x=1;x<W-1;x++) {
      if (grid[y][x]===T.FLOOR && items[y][x]===IT.NONE && !enemyAt(x,y) && !(player.x===x && player.y===y)) return {x,y};
    }
    return {x:1,y:1};
  }

  function enemyAt(x,y) {
    return enemies.find(e => e.x===x && e.y===y) || null;
  }

  function generateDungeon(newSeed, keepProgression=false) {
    seed = newSeed;
    rng = mulberry32(seed + floor * 1013904223); // mix with floor
    seedEl.textContent = String(seed >>> 0);

    initArrays();

    // rooms
    const rooms = [];
    for (let i = 0; i < ROOM_ATTEMPTS; i++) {
      const w = randInt(MIN_ROOM, MAX_ROOM);
      const h = randInt(MIN_ROOM, MAX_ROOM);
      const x = randInt(1, W - w - 2);
      const y = randInt(1, H - h - 2);
      const r = {x,y,w,h, cx: x + (w>>1), cy: y + (h>>1)};
      if (!roomIntersects(r, rooms)) {
        carveRoom(x,y,w,h);
        if (rooms.length > 0) {
          const prev = rooms[rooms.length-1];
          carveCorridor({x: prev.cx, y: prev.cy}, {x: r.cx, y: r.cy});
        }
        rooms.push(r);
      }
    }

    if (rooms.length === 0) {
      // ultra fallback
      carveRoom(2,2, W-4, H-4);
      rooms.push({x:2,y:2,w:W-4,h:H-4,cx:W>>1,cy:H>>1});
    }

    // place player at center of first room
    player.x = rooms[0].cx;
    player.y = rooms[0].cy;

    // place stairs far from player
    let stairs = null;
    let bestDist = -1;
    for (const r of rooms) {
      const candidate = {x:r.cx, y:r.cy};
      const d = manhattan(candidate, player);
      if (d > bestDist) { bestDist = d; stairs = candidate; }
    }
    items[stairs.y][stairs.x] = IT.STAIRS;

    // enemies (scale with floor)
    const enemyCount = clamp(Math.floor(MAX_ENEMIES_BASE + floor*1.2 + rng()*3), 6, 22);
    for (let i=0;i<enemyCount;i++) {
      const p = randomFloorCell();
      // keep enemies not too close to start
      if (manhattan(p, player) < 6) { i--; continue; }
      enemies.push({
        x:p.x, y:p.y,
        hp: 3 + Math.floor(floor*0.6) + randInt(0,2),
        atk: 1 + Math.floor(floor*0.25)
      });
    }

    // items
    const goldCount = clamp(8 + Math.floor(floor*1.4), 8, 30);
    const healCount = clamp(5 + Math.floor(floor*0.7), 4, 18);

    for (let i=0;i<goldCount;i++) {
      const p = randomFloorCell();
      items[p.y][p.x] = IT.GOLD;
    }
    for (let i=0;i<healCount;i++) {
      const p = randomFloorCell();
      items[p.y][p.x] = IT.HEAL;
    }

    // reset fog
    for (let y=0;y<H;y++) for (let x=0;x<W;x++) seen[y][x]=false;

    status(`Floor ${floor}. Explore.`);
    syncUI();
    draw();
  }

  // ========= Gameplay =========
  function status(msg) {
    statusEl.textContent = msg;
  }

  function syncUI() {
    floorEl.textContent = String(floor);
    hpEl.textContent = String(player.hp);
    hpMaxEl.textContent = String(player.hpMax);
    atkEl.textContent = String(player.atk);
    goldEl.textContent = String(player.gold);
  }

  function passable(x,y) {
    return x>=0 && y>=0 && x<W && y<H && grid[y][x] === T.FLOOR;
  }

  function reveal() {
    for (let dy=-VIEW_RADIUS; dy<=VIEW_RADIUS; dy++) {
      for (let dx=-VIEW_RADIUS; dx<=VIEW_RADIUS; dx++) {
        const x = player.x + dx, y = player.y + dy;
        if (x<0||y<0||x>=W||y>=H) continue;
        if (dx*dx + dy*dy <= VIEW_RADIUS*VIEW_RADIUS) seen[y][x]=true;
      }
    }
  }

  function pickUp() {
    const it = items[player.y][player.x];
    if (it === IT.NONE) return;

    if (it === IT.GOLD) {
      const g = 1 + Math.floor(rng()*3) + Math.floor(floor*0.25);
      player.gold += g;
      items[player.y][player.x] = IT.NONE;
      status(`Picked up ${g} gold.`);
    } else if (it === IT.HEAL) {
      const heal = 3 + Math.floor(rng()*4) + Math.floor(floor*0.15);
      const before = player.hp;
      player.hp = clamp(player.hp + heal, 0, player.hpMax);
      items[player.y][player.x] = IT.NONE;
      status(before === player.hp ? `Heal wasted (already full).` : `Healed +${player.hp - before}.`);
    } else if (it === IT.STAIRS) {
      status(`Stairs found. Tap “Next Floor” or press Enter.`);
    }
  }

  function attack(attacker, defender) {
    // small randomness
    const roll = (base) => Math.max(1, base + (rng()<0.5 ? 0 : 1) - (rng()<0.2 ? 1 : 0));
    const dmg = roll(attacker.atk);
    defender.hp -= dmg;
    return dmg;
  }

  function playerMove(dx, dy) {
    const nx = player.x + dx, ny = player.y + dy;
    if (!passable(nx, ny)) { status("Bump."); return; }

    const e = enemyAt(nx, ny);
    if (e) {
      // combat (player hits, then enemy hits if alive)
      const dmg = attack({atk: player.atk}, e);
      if (e.hp <= 0) {
        enemies = enemies.filter(x => x !== e);
        player.x = nx; player.y = ny;
        player.gold += 1; // small reward
        status(`You hit for ${dmg}. Enemy defeated (+1 gold).`);
        pickUp();
      } else {
        const ret = attack(e, player);
        status(`You hit for ${dmg}. Enemy hits for ${ret}.`);
      }
      if (player.hp <= 0) {
        gameOver();
        return;
      }
    } else {
      player.x = nx; player.y = ny;
      pickUp();
      status("Move.");
    }

    // enemy turn after successful action (move or attack)
    enemyTurn();
    reveal();
    syncUI();
    draw();
  }

  function enemyTurn() {
    // simple "smell" AI: if close, step toward player, else random drift
    for (const e of enemies) {
      if (player.hp <= 0) break;

      const d = manhattan(e, player);
      if (d === 1) {
        const dmg = attack(e, player);
        status(`Enemy hits for ${dmg}.`);
        if (player.hp <= 0) { gameOver(); return; }
        continue;
      }

      let dx = 0, dy = 0;
      if (d <= 7 && rng() < 0.85) {
        // pursue
        if (Math.abs(player.x - e.x) > Math.abs(player.y - e.y)) dx = Math.sign(player.x - e.x);
        else dy = Math.sign(player.y - e.y);
        // occasionally try the other axis
        if (rng() < 0.25) { [dx,dy] = [dy,dx]; }
      } else {
        // wander
        const r = randInt(0,3);
        dx = [1,-1,0,0][r];
        dy = [0,0,1,-1][r];
      }

      const nx = e.x + dx, ny = e.y + dy;
      if (nx===player.x && ny===player.y) continue;
      if (!passable(nx, ny)) continue;
      if (enemyAt(nx, ny)) continue;
      // don't step onto stairs to avoid annoyance
      if (items[ny][nx] === IT.STAIRS) continue;

      e.x = nx; e.y = ny;
    }
  }

  function gameOver() {
    status(`You died on floor ${floor}. Tap “New Dungeon”.`);
    // soft reset player stats but keep best run? For simplicity: reset everything.
    // (If you want a roguelike "meta-progression", we can add it.)
    draw(true);
  }

  function nextFloor() {
    if (items[player.y][player.x] !== IT.STAIRS) {
      status("You need to stand on the stairs (↧).");
      return;
    }
    floor += 1;
    // progression
    if (floor % 2 === 0) { player.hpMax += 2; player.atk += 1; }
    player.hp = player.hpMax;
    status(`Descending…`);
    floorEl.textContent = String(floor);
    generateDungeon(seed, true);
  }

  // ========= Rendering =========
  function draw(dead=false) {
    const cw = canvas.width, ch = canvas.height;
    const cell = Math.floor(Math.min(cw / W, ch / H));
    const ox = Math.floor((cw - cell * W) / 2);
    const oy = Math.floor((ch - cell * H) / 2);

    ctx.clearRect(0,0,cw,ch);

    // background vignette
    ctx.save();
    const g = ctx.createRadialGradient(cw/2, ch*0.2, 50, cw/2, ch/2, cw*0.65);
    g.addColorStop(0, 'rgba(120,160,255,0.12)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,cw,ch);
    ctx.restore();

    reveal();

    // tiles
    for (let y=0;y<H;y++) {
      for (let x=0;x<W;x++) {
        const vis = seen[y][x];
        const px = ox + x*cell, py = oy + y*cell;

        if (!vis) {
          ctx.fillStyle = 'rgba(0,0,0,0.88)';
          ctx.fillRect(px, py, cell, cell);
          continue;
        }

        if (grid[y][x] === T.WALL) {
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
          ctx.fillRect(px, py, cell, cell);
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(px, py, cell, cell);
        }
      }
    }

    // subtle grid lines (only on seen)
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#ffffff';
    for (let y=0;y<=H;y++) {
      const py = oy + y*cell;
      ctx.beginPath();
      ctx.moveTo(ox, py);
      ctx.lineTo(ox + W*cell, py);
      ctx.stroke();
    }
    for (let x=0;x<=W;x++) {
      const px = ox + x*cell;
      ctx.beginPath();
      ctx.moveTo(px, oy);
      ctx.lineTo(px, oy + H*cell);
      ctx.stroke();
    }
    ctx.restore();

    // items
    for (let y=0;y<H;y++) {
      for (let x=0;x<W;x++) {
        if (!seen[y][x]) continue;
        if (grid[y][x] !== T.FLOOR) continue;
        const it = items[y][x];
        if (it === IT.NONE) continue;

        const cx = ox + x*cell + cell/2;
        const cy = oy + y*cell + cell/2;

        ctx.save();
        if (it === IT.GOLD) {
          ctx.fillStyle = 'rgba(255,220,120,0.95)';
          ctx.shadowColor = 'rgba(255,220,120,0.35)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(cx, cy, cell*0.18, 0, Math.PI*2);
          ctx.fill();
        } else if (it === IT.HEAL) {
          ctx.fillStyle = 'rgba(120,255,180,0.95)';
          ctx.shadowColor = 'rgba(120,255,180,0.35)';
          ctx.shadowBlur = 10;
          ctx.fillRect(cx - cell*0.07, cy - cell*0.22, cell*0.14, cell*0.44);
          ctx.fillRect(cx - cell*0.22, cy - cell*0.07, cell*0.44, cell*0.14);
        } else if (it === IT.STAIRS) {
          ctx.strokeStyle = 'rgba(190,200,255,0.95)';
          ctx.shadowColor = 'rgba(190,200,255,0.35)';
          ctx.shadowBlur = 10;
          ctx.lineWidth = Math.max(2, cell*0.08);
          ctx.beginPath();
          ctx.moveTo(cx - cell*0.18, cy - cell*0.10);
          ctx.lineTo(cx, cy + cell*0.18);
          ctx.lineTo(cx + cell*0.18, cy - cell*0.10);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    // enemies
    for (const e of enemies) {
      if (!seen[e.y][e.x]) continue;
      const cx = ox + e.x*cell + cell/2;
      const cy = oy + e.y*cell + cell/2;
      ctx.save();
      ctx.fillStyle = 'rgba(255,90,110,0.95)';
      ctx.shadowColor = 'rgba(255,90,110,0.35)';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(cx, cy, cell*0.26, 0, Math.PI*2);
      ctx.fill();

      // tiny HP pip
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(cx - cell*0.22, cy + cell*0.30, cell*0.44, cell*0.10);
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      const pct = clamp(e.hp / (3 + Math.floor(floor*0.6) + 2), 0, 1);
      ctx.fillRect(cx - cell*0.22, cy + cell*0.30, cell*0.44*pct, cell*0.10);
      ctx.restore();
    }

    // player
    const pcx = ox + player.x*cell + cell/2;
    const pcy = oy + player.y*cell + cell/2;
    ctx.save();
    ctx.shadowColor = 'rgba(120,160,255,0.55)';
    ctx.shadowBlur = 16;
    ctx.fillStyle = dead ? 'rgba(160,160,160,0.8)' : 'rgba(120,160,255,0.95)';
    ctx.beginPath();
    ctx.arc(pcx, pcy, cell*0.28, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // crosshair / focus ring
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = Math.max(1, cell*0.05);
    ctx.beginPath();
    ctx.arc(pcx, pcy, cell*0.42, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // overlay if dead
    if (player.hp <= 0) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,cw,ch);
      ctx.fillStyle = '#e9eef7';
      ctx.textAlign = 'center';
      ctx.font = '800 52px -apple-system, system-ui, sans-serif';
      ctx.fillText('You Died', cw/2, ch/2 - 10);
      ctx.globalAlpha = 0.9;
      ctx.font = '500 18px -apple-system, system-ui, sans-serif';
      ctx.fillText('Tap New Dungeon to try again', cw/2, ch/2 + 34);
      ctx.restore();
    }
  }

  // ========= Input =========
  function handleKey(e) {
    const k = e.key.toLowerCase();
    if (player.hp <= 0) return;

    if (k === 'arrowup' || k === 'w') playerMove(0,-1);
    else if (k === 'arrowdown' || k === 's') playerMove(0, 1);
    else if (k === 'arrowleft' || k === 'a') playerMove(-1,0);
    else if (k === 'arrowright' || k === 'd') playerMove(1, 0);
    else if (k === 'enter') nextFloor();
  }

  window.addEventListener('keydown', (e) => {
    const keys = ['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','enter'];
    if (keys.includes(e.key.toLowerCase())) e.preventDefault();
    handleKey(e);
  });

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    touchStart = { x: e.clientX, y: e.clientY, t: performance.now() };
  });

  canvas.addEventListener('pointerup', (e) => {
    if (!touchStart || player.hp <= 0) { touchStart = null; return; }
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);

    // small swipe threshold
    const TH = 22;
    if (adx < TH && ady < TH) { touchStart = null; return; }

    if (adx > ady) playerMove(Math.sign(dx), 0);
    else playerMove(0, Math.sign(dy));

    touchStart = null;
  });

  // Buttons
  newBtn.addEventListener('click', () => {
    floor = 1;
    player = { x: 1, y: 1, hp: 10, hpMax: 10, atk: 2, gold: 0 };
    generateDungeon(makeSeed());
  });

  nextBtn.addEventListener('click', () => nextFloor());

  // ========= Start =========
  function start() {
    floor = 1;
    player = { x: 1, y: 1, hp: 10, hpMax: 10, atk: 2, gold: 0 };
    generateDungeon(makeSeed());
  }

  start();
})();
</script>
</body>
</html>
